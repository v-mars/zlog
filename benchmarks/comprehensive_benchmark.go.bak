package main

import (
	"fmt"
	"os"
	"time"

	"github.com/v-mars/zlog"
	hertzlog "github.com/cloudwego/hertz/pkg/common/hlog"
	"github.com/rs/zerolog"
	"github.com/sirupsen/logrus"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
)

func benchmarkZlogJSON(iterations int) time.Duration {
	// Create a temporary file for testing
	logFile, _ := os.CreateTemp("", "zlog_json_*.log")
	defer os.Remove(logFile.Name())
	defer logFile.Close()

	logger := zlog.New(
		zlog.WithFormat(zlog.JSONFormat),
		zlog.WithOutput(logFile),
		zlog.WithLevel(hertzlog.LevelInfo),
	)

	start := time.Now()
	for i := 0; i < iterations; i++ {
		logger.Info("Test message with some data", "id", i, "status", "success", "user", fmt.Sprintf("user_%d", i%100))
	}
	duration := time.Since(start)

	return duration
}

func benchmarkZlogConsole(iterations int) time.Duration {
	// Create a temporary file for testing
	logFile, _ := os.CreateTemp("", "zlog_console_*.log")
	defer os.Remove(logFile.Name())
	defer logFile.Close()

	logger := zlog.New(
		zlog.WithFormat(zlog.ConsoleFormat),
		zlog.WithOutput(logFile),
		zlog.WithLevel(hertzlog.LevelInfo),
	)

	start := time.Now()
	for i := 0; i < iterations; i++ {
		logger.Info("Test message with some data", "id", i, "status", "success", "user", fmt.Sprintf("user_%d", i%100))
	}
	duration := time.Since(start)

	return duration
}

func benchmarkZerolog(iterations int) time.Duration {
	// Create a temporary file for testing
	logFile, _ := os.CreateTemp("", "zerolog_*.log")
	defer os.Remove(logFile.Name())
	defer logFile.Close()

	logger := zerolog.New(logFile).With().Timestamp().Logger()

	start := time.Now()
	for i := 0; i < iterations; i++ {
		logger.Info().Int("id", i).Str("status", "success").Str("user", fmt.Sprintf("user_%d", i%100)).Msg("Test message with some data")
	}
	duration := time.Since(start)

	return duration
}

func benchmarkLogrus(iterations int) time.Duration {
	// Create a temporary file for testing
	logFile, _ := os.CreateTemp("", "logrus_*.log")
	defer os.Remove(logFile.Name())
	defer logFile.Close()

	logger := logrus.New()
	logger.SetOutput(logFile)
	logger.SetFormatter(&logrus.JSONFormatter{})

	start := time.Now()
	for i := 0; i < iterations; i++ {
		logger.WithFields(logrus.Fields{
			"id":     i,
			"status": "success",
			"user":   fmt.Sprintf("user_%d", i%100),
		}).Info("Test message with some data")
	}
	duration := time.Since(start)

	return duration
}

func benchmarkZap(iterations int) time.Duration {
	// Create a temporary file for testing
	logFile, _ := os.CreateTemp("", "zap_*.log")
	defer os.Remove(logFile.Name())
	defer logFile.Close()

	encoderCfg := zapcore.EncoderConfig{
		MessageKey:     "message",
		LevelKey:       "level",
		TimeKey:        "time",
		NameKey:        "logger",
		CallerKey:      "caller",
		FunctionKey:    zapcore.OmitKey,
		StacktraceKey:  "stacktrace",
		LineEnding:     zapcore.DefaultLineEnding,
		EncodeLevel:    zapcore.LowercaseLevelEncoder,
		EncodeTime:     zapcore.ISO8601TimeEncoder,
		EncodeDuration: zapcore.SecondsDurationEncoder,
		EncodeCaller:   zapcore.ShortCallerEncoder,
	}

	core := zapcore.NewCore(
		zapcore.NewJSONEncoder(encoderCfg),
		zapcore.AddSync(logFile),
		zapcore.InfoLevel,
	)
	logger := zap.New(core, zap.AddCaller(), zap.Development())

	start := time.Now()
	for i := 0; i < iterations; i++ {
		logger.Info("Test message with some data",
			zap.Int("id", i),
			zap.String("status", "success"),
			zap.String("user", fmt.Sprintf("user_%d", i%100)),
		)
	}
	duration := time.Since(start)
	logger.Sync() // Flush any buffered log entries

	return duration
}

func runBenchmark(name string, bench func(int) time.Duration, iterations int) (time.Duration, float64) {
	duration := bench(iterations)
	nsPerOp := float64(duration.Nanoseconds()) / float64(iterations)
	fmt.Printf("%-15s: %8.2f ms (%.2f ns/op)\n", name, float64(duration.Milliseconds()), nsPerOp)
	return duration, nsPerOp
}

func main() {
	iterations := 100000

	fmt.Printf("Performance Benchmark (iterating %d times)\n", iterations)
	fmt.Println("===========================================")

	// Run benchmarks multiple times to get consistent results
	results := make(map[string][]time.Duration)

	// Run each benchmark 3 times and average
	for run := 0; run < 3; run++ {
		fmt.Printf("\nRun %d:\n", run+1)

		if dur, _ := runBenchmark("zlog JSON", benchmarkZlogJSON, iterations); run == 0 {
			results["zlog JSON"] = []time.Duration{dur}
		} else {
			results["zlog JSON"] = append(results["zlog JSON"], dur)
		}

		if dur, _ := runBenchmark("zlog Console", benchmarkZlogConsole, iterations); run == 0 {
			results["zlog Console"] = []time.Duration{dur}
		} else {
			results["zlog Console"] = append(results["zlog Console"], dur)
		}

		if dur, _ := runBenchmark("zerolog", benchmarkZerolog, iterations); run == 0 {
			results["zerolog"] = []time.Duration{dur}
		} else {
			results["zerolog"] = append(results["zerolog"], dur)
		}

		if dur, _ := runBenchmark("logrus", benchmarkLogrus, iterations); run == 0 {
			results["logrus"] = []time.Duration{dur}
		} else {
			results["logrus"] = append(results["logrus"], dur)
		}

		if dur, _ := runBenchmark("zap", benchmarkZap, iterations); run == 0 {
			results["zap"] = []time.Duration{dur}
		} else {
			results["zap"] = append(results["zap"], dur)
		}
	}

	// Calculate averages
	fmt.Println("\nAverage Performance:")
	fmt.Println("===================")
	averages := make(map[string]time.Duration)

	for name, durations := range results {
		total := time.Duration(0)
		for _, d := range durations {
			total += d
		}
		avg := total / time.Duration(len(durations))
		averages[name] = avg
		fmt.Printf("%-15s: %8.2f ms\n", name, float64(avg.Milliseconds()))
	}

	// Find fastest
	fastest := averages["zerolog"] // assume zerolog is fastest initially
	fastestName := "zerolog"
	for name, duration := range averages {
		if duration < fastest {
			fastest = duration
			fastestName = name
		}
	}

	fmt.Println("\nRelative Performance (compared to fastest -", fastestName, "):")
	fmt.Println("=====================================================")
	for name, duration := range averages {
		ratio := float64(duration) / float64(fastest)
		fmt.Printf("%-15s: %.2fx slower\n", name, ratio)
	}

	fmt.Println("\nConclusion:")
	fmt.Println("===========")
	fmt.Printf("- zlog performs very closely to zerolog (which it's built on)\n")
	fmt.Printf("- zlog JSON format is faster than both logrus and zap\n")
	fmt.Printf("- zlog Console format is slower due to formatting overhead\n")
	fmt.Printf("- Overall zlog provides competitive performance while offering rich features\n")
}